%{
/* vim: set ft=lex: */
//#include "lexer.hpp"

#include "../strings/rstring.hpp"
#include "../strings/zstring.hpp"

#include "../io/cxxstdio.hpp"

#include "../sexpr/lexer.hpp"

#include "parser.hpp"

#define yylval spell_converterlval

RString *str(const char *s)
{
    return new RString(ZString(strings::really_construct_from_a_pointer, s, nullptr));
}
%}

%option noyywrap
%option prefix="spell_converter"
%option nounput
%option noinput

%%

"S"                     { yylval.s = str(yytext); return DIR; }
"SW"                    { yylval.s = str(yytext); return DIR; }
"W"                     { yylval.s = str(yytext); return DIR; }
"NW"                    { yylval.s = str(yytext); return DIR; }
"N"                     { yylval.s = str(yytext); return DIR; }
"NE"                    { yylval.s = str(yytext); return DIR; }
"E"                     { yylval.s = str(yytext); return DIR; }
"SE"                    { yylval.s = str(yytext); return DIR; }
"="                     { return '='; }
"=="                    { return EQ; }
"<>"                    { return NEQ; }
"!="                    { return NEQ; }
">"                     { return '>'; }
"<"                     { return '<'; }
">="                    { return GTE; }
"<="                    { return LTE; }
"("                     { return '('; }
")"                     { return ')'; }
"+"                     { return '+'; }
"-"                     { return '-'; }
"*"                     { return '*'; }
"/"                     { return '/'; }
"%"                     { return '%'; }
"&&"                    { return ANDAND; }
"||"                    { return OROR; }
";"                     { return ';'; }
":"                     { return ':'; }
","                     { return ','; }
"@"                     { return '@'; }
"|"                     { return '|'; }
"["                     { return '['; }
"]"                     { return ']'; }
"&"                     { return '&'; }
"^"                     { return '^'; }
"."                     { return '.'; }
"<<"                    { return SHL; }
">>"                    { return SHR; }
"PROCEDURE"             { return PROCEDURE; }
"CALL"                  { return CALL; }
"OR"                    { return OR; }
"TO"                    { return TO; }
"TOWARDS"               { return TOWARDS; }
"TELEPORT-ANCHOR"       { return TELEPORT_ANCHOR; }
"SILENT"                { return SILENT; }
"LOCAL"                 { return LOCAL; }
"NONMAGIC"              { return NONMAGIC; }
"SPELL"                 { return SPELL; }
"LET"                   { return LET; }
"IN"                    { return IN; }
"END"                   { return END; }
"=>"                    { return DARROW; }
"STRING"                { return STRING_TY; }
"REQUIRE"               { return REQUIRE; }
"CATALYSTS"             { return CATALYSTS; }
"COMPONENTS"            { return COMPONENTS; }
"MANA"                  { return MANA; }
"CASTTIME"              { return CASTTIME; }
"SKIP"                  { return SKIP; }
"ABORT"                 { return ABORT; }
"BREAK"                 { return BREAK; }
"EFFECT"                { return EFFECT_; }
"ATEND"                 { return ATEND; }
"ATTRIGGER"             { return ATTRIGGER; }
"CONST"                 { return CONST; }
"PC"                    { return PC_F; }
"NPC"                   { return NPC_F; }
"MOB"                   { return MOB_F; }
"ENTITY"                { return ENTITY_F; }
"TARGET"                { return TARGET_F; }
"IF"                    { return IF; }
"THEN"                  { return THEN; }
"ELSE"                  { return ELSE; }
"FOREACH"               { return FOREACH; }
"FOR"                   { return FOR; }
"DO"                    { return DO; }
"WAIT"                  { return SLEEP; }

\{([^\}]|\\.)*\}        { yylval.s = str(yytext); return SCRIPT_DATA; }
\"([^\"]|\\.)*\"        { yylval.s = str(yytext); return STRING; }
"-"?[0-9]+              { yylval.s = str(yytext); return INT; }
"0x"[0-9a-fA-F]+        { yylval.s = str(yytext); return INT; }
[a-zA-Z][-_a-zA-Z0-9]*  { yylval.s = str(yytext); return ID; }
"#".*$                  { PRINTF("%s\n", sexpr::escape(*str(yytext + 1))); }
"//".*$                 { PRINTF("%s\n", sexpr::escape(*str(yytext + 2))); }
[ \n\t\r]               /* ignore whitespace */
.                       { abort(); }

%%
// nothing to see here, move along
